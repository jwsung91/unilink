<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>unilink: Unilink Best Practices Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">unilink
   &#160;<span id="projectnumber">0.3.3</span>
   </div>
   <div id="projectbrief">A simple C++ library for unified async communication</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_docs_guides_core_best_practices.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Unilink Best Practices Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Learn the recommended patterns and practices for using unilink effectively.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md286"></a>
Table of Contents</h1>
<ol type="1">
<li><a href="#error-handling">Error Handling</a></li>
<li><a href="#resource-management">Resource Management</a></li>
<li><a href="#thread-safety">Thread Safety</a></li>
<li><a href="#performance-optimization">Performance Optimization</a></li>
<li><a href="#code-organization">Code Organization</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#security">Security</a></li>
<li><a href="#logging-and-debugging">Logging and Debugging</a></li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md288"></a>
Error Handling</h1>
<h2><a class="anchor" id="autotoc_md289"></a>
✅ DO: Always Register Error Callbacks</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD</span></div>
<div class="line"><span class="keyword">auto</span> client = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">unilink::tcp_client</a>(<span class="stringliteral">&quot;server.com&quot;</span>, 8080)</div>
<div class="line">    .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a13494649fcb5f8f8f4fbf8909a1e2e71">on_error</a>([](<span class="keyword">const</span> std::string&amp; error) {</div>
<div class="line">        log_error(<span class="stringliteral">&quot;TCP Client&quot;</span>, error);</div>
<div class="line">        <span class="comment">// Handle error appropriately</span></div>
<div class="line">    })</div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// BAD - No error handling</span></div>
<div class="line"><span class="keyword">auto</span> client = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">unilink::tcp_client</a>(<span class="stringliteral">&quot;server.com&quot;</span>, 8080)</div>
<div class="line">    .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a5a4af5b627ffc15c727cba9fa2fa1d93">build</a>();  <span class="comment">// Errors will be silently ignored!</span></div>
<div class="ttc" id="aclassunilink_1_1builder_1_1TcpClientBuilder_html_a13494649fcb5f8f8f4fbf8909a1e2e71"><div class="ttname"><a href="classunilink_1_1builder_1_1TcpClientBuilder.html#a13494649fcb5f8f8f4fbf8909a1e2e71">unilink::builder::TcpClientBuilder::on_error</a></div><div class="ttdeci">TcpClientBuilder &amp; on_error(std::function&lt; void(const std::string &amp;)&gt; handler) override</div><div class="ttdoc">Set error handler callback.</div><div class="ttdef"><b>Definition:</b> <a href="tcp__client__builder_8cc_source.html#l00136">tcp_client_builder.cc:136</a></div></div>
<div class="ttc" id="aclassunilink_1_1builder_1_1TcpClientBuilder_html_a5a4af5b627ffc15c727cba9fa2fa1d93"><div class="ttname"><a href="classunilink_1_1builder_1_1TcpClientBuilder.html#a5a4af5b627ffc15c727cba9fa2fa1d93">unilink::builder::TcpClientBuilder::build</a></div><div class="ttdeci">std::unique_ptr&lt; wrapper::TcpClient &gt; build() override</div><div class="ttdoc">Build and return the configured TcpClient.</div><div class="ttdef"><b>Definition:</b> <a href="tcp__client__builder_8cc_source.html#l00046">tcp_client_builder.cc:46</a></div></div>
<div class="ttc" id="anamespaceunilink_html_a6e965071daa5a68d914844bfbf79daac"><div class="ttname"><a href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">unilink::tcp_client</a></div><div class="ttdeci">builder::TcpClientBuilder tcp_client(const std::string &amp;host, uint16_t port)</div><div class="ttdoc">Create a TCP client builder.</div><div class="ttdef"><b>Definition:</b> <a href="unilink_8hpp_source.html#l00095">unilink.hpp:95</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md290"></a>
✅ DO: Check Connection Status Before Sending</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD</span></div>
<div class="line"><span class="keywordflow">if</span> (client-&gt;is_connected()) {</div>
<div class="line">    client-&gt;send(<span class="stringliteral">&quot;Hello&quot;</span>);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    log_warning(<span class="stringliteral">&quot;Cannot send - not connected&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// BAD - Send without checking</span></div>
<div class="line">client-&gt;send(<span class="stringliteral">&quot;Hello&quot;</span>);  <span class="comment">// May fail silently</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md291"></a>
✅ DO: Implement Graceful Error Recovery</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Graceful recovery</span></div>
<div class="line"><span class="keyword">auto</span> client = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">unilink::tcp_client</a>(<span class="stringliteral">&quot;server.com&quot;</span>, 8080)</div>
<div class="line">    .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a13494649fcb5f8f8f4fbf8909a1e2e71">on_error</a>([<span class="keyword">this</span>](<span class="keyword">const</span> std::string&amp; error) {</div>
<div class="line">        log_error(error);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Categorize error</span></div>
<div class="line">        <span class="keywordflow">if</span> (is_retryable(error)) {</div>
<div class="line">            schedule_retry();</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            notify_user(<span class="stringliteral">&quot;Connection failed permanently&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    })</div>
<div class="line">    .retry_interval(5000)  <span class="comment">// Auto-retry</span></div>
<div class="line">    .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a5a4af5b627ffc15c727cba9fa2fa1d93">build</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// BAD - No recovery strategy</span></div>
<div class="line"><span class="keyword">auto</span> client = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">unilink::tcp_client</a>(<span class="stringliteral">&quot;server.com&quot;</span>, 8080)</div>
<div class="line">    .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a13494649fcb5f8f8f4fbf8909a1e2e71">on_error</a>([](<span class="keyword">const</span> std::string&amp; error) {</div>
<div class="line">        std::cerr &lt;&lt; error &lt;&lt; std::endl;  <span class="comment">// Just print and hope</span></div>
<div class="line">    })</div>
<div class="line">    .build();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md292"></a>
✅ DO: Use Centralized Error Handler</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Centralized error management</span></div>
<div class="line"><span class="keywordtype">void</span> setup_error_handler() {</div>
<div class="line">    unilink::common::ErrorHandler::instance()</div>
<div class="line">        .register_callback([](<span class="keyword">const</span> ErrorInfo&amp; error) {</div>
<div class="line">            <span class="comment">// Log to file</span></div>
<div class="line">            log_to_file(error);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Send to monitoring</span></div>
<div class="line">            send_to_monitoring(error);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Alert on critical</span></div>
<div class="line">            <span class="keywordflow">if</span> (error.level == ErrorLevel::CRITICAL) {</div>
<div class="line">                send_alert(error);</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use in multiple components</span></div>
<div class="line"><span class="keyword">auto</span> client1 = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">tcp_client</a>(<span class="stringliteral">&quot;server1.com&quot;</span>, 8080).<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a5a4af5b627ffc15c727cba9fa2fa1d93">build</a>();</div>
<div class="line"><span class="keyword">auto</span> client2 = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">tcp_client</a>(<span class="stringliteral">&quot;server2.com&quot;</span>, 8080).<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a5a4af5b627ffc15c727cba9fa2fa1d93">build</a>();</div>
<div class="line"><span class="comment">// Both use the same error handler</span></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md294"></a>
Resource Management</h1>
<h2><a class="anchor" id="autotoc_md295"></a>
✅ DO: Use RAII and Smart Pointers</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Automatic cleanup</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> client = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">unilink::tcp_client</a>(<span class="stringliteral">&quot;server.com&quot;</span>, 8080)</div>
<div class="line">        .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a2b5c3a4512e9c13dba24b8adb4aaf0de">auto_manage</a>(<span class="keyword">true</span>)  <span class="comment">// Auto cleanup</span></div>
<div class="line">        .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a5a4af5b627ffc15c727cba9fa2fa1d93">build</a>();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Use client...</span></div>
<div class="line">    </div>
<div class="line">}  <span class="comment">// client automatically cleaned up here</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// BAD - Manual cleanup required</span></div>
<div class="line"><span class="keyword">auto</span>* client = <span class="keyword">new</span> TcpClient(...);</div>
<div class="line"><span class="comment">// ... use client ...</span></div>
<div class="line">client-&gt;stop();  <span class="comment">// Must remember to call</span></div>
<div class="line"><span class="keyword">delete</span> client;   <span class="comment">// Must remember to delete</span></div>
<div class="ttc" id="aclassunilink_1_1builder_1_1TcpClientBuilder_html_a2b5c3a4512e9c13dba24b8adb4aaf0de"><div class="ttname"><a href="classunilink_1_1builder_1_1TcpClientBuilder.html#a2b5c3a4512e9c13dba24b8adb4aaf0de">unilink::builder::TcpClientBuilder::auto_manage</a></div><div class="ttdeci">TcpClientBuilder &amp; auto_manage(bool auto_manage=true) override</div><div class="ttdoc">Enable auto-manage functionality.</div><div class="ttdef"><b>Definition:</b> <a href="tcp__client__builder_8cc_source.html#l00116">tcp_client_builder.cc:116</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md296"></a>
✅ DO: Stop Connections Before Shutdown</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Graceful shutdown</span></div>
<div class="line"><span class="keyword">class </span>Application {</div>
<div class="line">    std::shared_ptr&lt;unilink::wrapper::TcpClient&gt; client_;</div>
<div class="line">    </div>
<div class="line">    ~Application() {</div>
<div class="line">        shutdown();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> shutdown() {</div>
<div class="line">        <span class="keywordflow">if</span> (client_) {</div>
<div class="line">            client_-&gt;send(<span class="stringliteral">&quot;GOODBYE&quot;</span>);</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">            client_-&gt;stop();</div>
<div class="line">            client_.reset();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// BAD - Abrupt shutdown</span></div>
<div class="line"><span class="keyword">class </span>Application {</div>
<div class="line">    std::shared_ptr&lt;unilink::wrapper::TcpClient&gt; client_;</div>
<div class="line">    </div>
<div class="line">    ~Application() {</div>
<div class="line">        <span class="comment">// client_ destroyed abruptly</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>Tip: Register all callbacks before calling <code>.auto_manage(true)</code> or manually invoking <code>start()</code>, because <code>auto_manage(true)</code> now starts the connection immediately. </p>
</blockquote>
<blockquote class="doxtable">
<p>Advanced: If you supply your own <code>boost::asio::io_context</code> to the wrappers, unilink will not run or stop it for you (unless you explicitly opt in with <code>set_manage_external_context(true)</code>). Make sure the context is running on a thread you control. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md297"></a>
✅ DO: Reuse Connections When Possible</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Reuse connection</span></div>
<div class="line"><span class="keyword">class </span>DataSender {</div>
<div class="line">    std::shared_ptr&lt;unilink::wrapper::TcpClient&gt; client_;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> send_multiple_messages() {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; msg : messages) {</div>
<div class="line">            <span class="keywordflow">if</span> (client_-&gt;is_connected()) {</div>
<div class="line">                client_-&gt;send(msg);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// BAD - Create new connection each time</span></div>
<div class="line"><span class="keywordtype">void</span> send_message(<span class="keyword">const</span> std::string&amp; msg) {</div>
<div class="line">    <span class="keyword">auto</span> client = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">tcp_client</a>(<span class="stringliteral">&quot;server.com&quot;</span>, 8080).<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a5a4af5b627ffc15c727cba9fa2fa1d93">build</a>();</div>
<div class="line">    client-&gt;start();</div>
<div class="line">    client-&gt;send(msg);</div>
<div class="line">    client-&gt;stop();  <span class="comment">// Wasteful!</span></div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md299"></a>
Thread Safety</h1>
<h2><a class="anchor" id="autotoc_md300"></a>
✅ DO: Protect Shared State</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Thread-safe state management</span></div>
<div class="line"><span class="keyword">class </span>Server {</div>
<div class="line">    std::mutex clients_mutex_;</div>
<div class="line">    std::map&lt;size_t, ClientInfo&gt; clients_;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> add_client(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> ClientInfo&amp; info) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(clients_mutex_);</div>
<div class="line">        clients_[id] = info;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">size_t</span> get_client_count()<span class="keyword"> const </span>{</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(clients_mutex_);</div>
<div class="line">        <span class="keywordflow">return</span> clients_.size();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// BAD - Race condition</span></div>
<div class="line"><span class="keyword">class </span>Server {</div>
<div class="line">    std::map&lt;size_t, ClientInfo&gt; clients_;  <span class="comment">// Not protected!</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> add_client(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> ClientInfo&amp; info) {</div>
<div class="line">        clients_[id] = info;  <span class="comment">// UNSAFE from multiple threads!</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md301"></a>
✅ DO: Use ThreadSafeState for Complex States</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Use provided thread-safe utilities</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="thread__safe__state_8hpp.html">unilink/concurrency/thread_safe_state.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Connection {</div>
<div class="line">    unilink::common::ThreadSafeState&lt;State&gt; state_;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> set_state(State new_state) {</div>
<div class="line">        state_.set(new_state);  <span class="comment">// Thread-safe</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    State get_state()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> state_.get();  <span class="comment">// Thread-safe</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="athread__safe__state_8hpp_html"><div class="ttname"><a href="thread__safe__state_8hpp.html">thread_safe_state.hpp</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md302"></a>
❌ DON'T: Block in Callbacks</h2>
<div class="fragment"><div class="line"><span class="comment">// BAD - Blocking in callback</span></div>
<div class="line"><span class="keyword">auto</span> client = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">tcp_client</a>(<span class="stringliteral">&quot;server.com&quot;</span>, 8080)</div>
<div class="line">    .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#af0f78cdc2328bf0d06ef3789b3e4e41d">on_data</a>([](<span class="keyword">const</span> std::string&amp; data) {</div>
<div class="line">        <span class="comment">// This blocks the I/O thread!</span></div>
<div class="line">        std::this_thread::sleep_for(std::chrono::seconds(10));</div>
<div class="line">        process_data(data);</div>
<div class="line">    })</div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// GOOD - Process asynchronously</span></div>
<div class="line"><span class="keyword">auto</span> client = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">tcp_client</a>(<span class="stringliteral">&quot;server.com&quot;</span>, 8080)</div>
<div class="line">    .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#af0f78cdc2328bf0d06ef3789b3e4e41d">on_data</a>([<span class="keyword">this</span>](<span class="keyword">const</span> std::string&amp; data) {</div>
<div class="line">        <span class="comment">// Queue for processing in another thread</span></div>
<div class="line">        message_queue_.push(data);</div>
<div class="line">    })</div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Separate processing thread</span></div>
<div class="line"><span class="keywordtype">void</span> processing_thread() {</div>
<div class="line">    <span class="keywordflow">while</span> (running_) {</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">auto</span> msg = message_queue_.pop()) {</div>
<div class="line">            process_data(*msg);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassunilink_1_1builder_1_1TcpClientBuilder_html_af0f78cdc2328bf0d06ef3789b3e4e41d"><div class="ttname"><a href="classunilink_1_1builder_1_1TcpClientBuilder.html#af0f78cdc2328bf0d06ef3789b3e4e41d">unilink::builder::TcpClientBuilder::on_data</a></div><div class="ttdeci">TcpClientBuilder &amp; on_data(std::function&lt; void(const std::string &amp;)&gt; handler) override</div><div class="ttdoc">Set data handler callback.</div><div class="ttdef"><b>Definition:</b> <a href="tcp__client__builder_8cc_source.html#l00121">tcp_client_builder.cc:121</a></div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md304"></a>
Performance Optimization</h1>
<h2><a class="anchor" id="autotoc_md305"></a>
✅ DO: Use Move Semantics</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Move instead of copy</span></div>
<div class="line">std::string large_data = generate_large_data();</div>
<div class="line">client-&gt;send(std::move(large_data));  <span class="comment">// Move, no copy</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// BAD - Unnecessary copy</span></div>
<div class="line">std::string large_data = generate_large_data();</div>
<div class="line">client-&gt;send(large_data);  <span class="comment">// Copy entire string</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md306"></a>
✅ DO: Enable Async Logging</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Async logging for performance</span></div>
<div class="line">unilink::common::Logger::instance().enable_async(<span class="keyword">true</span>);</div>
<div class="line">unilink::common::Logger::instance().set_batch_size(100);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now logging is non-blocking</span></div>
<div class="line">logger.info(<span class="stringliteral">&quot;component&quot;</span>, <span class="stringliteral">&quot;operation&quot;</span>, <span class="stringliteral">&quot;message&quot;</span>);  <span class="comment">// Fast!</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md307"></a>
✅ DO: Use Shared IO Context (Default)</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Shared context (efficient)</span></div>
<div class="line"><span class="keyword">auto</span> client1 = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">tcp_client</a>(<span class="stringliteral">&quot;server1.com&quot;</span>, 8080).<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a5a4af5b627ffc15c727cba9fa2fa1d93">build</a>();</div>
<div class="line"><span class="keyword">auto</span> client2 = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">tcp_client</a>(<span class="stringliteral">&quot;server2.com&quot;</span>, 8080).<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a5a4af5b627ffc15c727cba9fa2fa1d93">build</a>();</div>
<div class="line"><span class="comment">// Both share one I/O thread - efficient</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Only use independent context when needed for testing</span></div>
<div class="line"><span class="keyword">auto</span> test_client = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">tcp_client</a>(<span class="stringliteral">&quot;test.com&quot;</span>, 8080)</div>
<div class="line">    .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a567fa16a7c094edee54a0ea2fec74fcd">use_independent_context</a>(<span class="keyword">true</span>)  <span class="comment">// Only for tests</span></div>
<div class="line">    .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a5a4af5b627ffc15c727cba9fa2fa1d93">build</a>();</div>
<div class="ttc" id="aclassunilink_1_1builder_1_1TcpClientBuilder_html_a567fa16a7c094edee54a0ea2fec74fcd"><div class="ttname"><a href="classunilink_1_1builder_1_1TcpClientBuilder.html#a567fa16a7c094edee54a0ea2fec74fcd">unilink::builder::TcpClientBuilder::use_independent_context</a></div><div class="ttdeci">TcpClientBuilder &amp; use_independent_context(bool use_independent=true)</div><div class="ttdoc">Use independent IoContext for this client (for testing isolation)</div><div class="ttdef"><b>Definition:</b> <a href="tcp__client__builder_8cc_source.html#l00141">tcp_client_builder.cc:141</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md308"></a>
✅ DO: Batch Small Messages</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Batch small messages</span></div>
<div class="line"><span class="keyword">class </span>MessageBatcher {</div>
<div class="line">    std::vector&lt;std::string&gt; batch_;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> max_batch_size_{100};</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> add_message(<span class="keyword">const</span> std::string&amp; msg) {</div>
<div class="line">        batch_.push_back(msg);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (batch_.size() &gt;= max_batch_size_) {</div>
<div class="line">            flush();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> flush() {</div>
<div class="line">        std::string combined;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; msg : batch_) {</div>
<div class="line">            combined += msg + <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        client_-&gt;send(combined);</div>
<div class="line">        batch_.clear();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// BAD - Send each message individually</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; msg : small_messages) {</div>
<div class="line">    client-&gt;send(msg);  <span class="comment">// Many small sends - inefficient</span></div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md310"></a>
Code Organization</h1>
<h2><a class="anchor" id="autotoc_md311"></a>
✅ DO: Use Classes for Complex Logic</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Organized in a class</span></div>
<div class="line"><span class="keyword">class </span>ChatClient {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;unilink::wrapper::TcpClient&gt; client_;</div>
<div class="line">    std::string nickname_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> connect(<span class="keyword">const</span> std::string&amp; server, uint16_t port) {</div>
<div class="line">        client_ = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">unilink::tcp_client</a>(server, port)</div>
<div class="line">            .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a4ae0c7b5b6f6c02066844fcb5a71ad9a">on_connect</a>([<span class="keyword">this</span>]() { handle_connect(); })</div>
<div class="line">            .on_data([<span class="keyword">this</span>](<span class="keyword">const</span> std::string&amp; data) { handle_data(data); })</div>
<div class="line">            .on_disconnect([<span class="keyword">this</span>]() { handle_disconnect(); })</div>
<div class="line">            .build();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> handle_connect() { <span class="comment">/* ... */</span> }</div>
<div class="line">    <span class="keywordtype">void</span> handle_data(<span class="keyword">const</span> std::string&amp; data) { <span class="comment">/* ... */</span> }</div>
<div class="line">    <span class="keywordtype">void</span> handle_disconnect() { <span class="comment">/* ... */</span> }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// BAD - Everything in main()</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">auto</span> client = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">tcp_client</a>(<span class="stringliteral">&quot;server.com&quot;</span>, 8080)</div>
<div class="line">        .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a4ae0c7b5b6f6c02066844fcb5a71ad9a">on_connect</a>([]() { <span class="comment">/* 100 lines of code */</span> })</div>
<div class="line">        .on_data([](<span class="keyword">const</span> std::string&amp; data) { <span class="comment">/* 200 lines */</span> })</div>
<div class="line">        .build();</div>
<div class="line">    <span class="comment">// Hard to maintain!</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassunilink_1_1builder_1_1TcpClientBuilder_html_a4ae0c7b5b6f6c02066844fcb5a71ad9a"><div class="ttname"><a href="classunilink_1_1builder_1_1TcpClientBuilder.html#a4ae0c7b5b6f6c02066844fcb5a71ad9a">unilink::builder::TcpClientBuilder::on_connect</a></div><div class="ttdeci">TcpClientBuilder &amp; on_connect(std::function&lt; void()&gt; handler) override</div><div class="ttdoc">Set connection handler callback.</div><div class="ttdef"><b>Definition:</b> <a href="tcp__client__builder_8cc_source.html#l00126">tcp_client_builder.cc:126</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md312"></a>
✅ DO: Separate Concerns</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Separated concerns</span></div>
<div class="line"><span class="keyword">class </span>NetworkManager {</div>
<div class="line">    <span class="keywordtype">void</span> connect() { <span class="comment">/* network logic */</span> }</div>
<div class="line">    <span class="keywordtype">void</span> disconnect() { <span class="comment">/* network logic */</span> }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MessageHandler {</div>
<div class="line">    <span class="keywordtype">void</span> process_message(<span class="keyword">const</span> std::string&amp; msg) { <span class="comment">/* business logic */</span> }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Application {</div>
<div class="line">    NetworkManager network_;</div>
<div class="line">    MessageHandler handler_;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        network_.on_data([<span class="keyword">this</span>](<span class="keyword">const</span> std::string&amp; msg) {</div>
<div class="line">            handler_.process_message(msg);  <span class="comment">// Delegate</span></div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// BAD - Mixed concerns</span></div>
<div class="line"><span class="keyword">class </span>Application {</div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        client_-&gt;on_data([](<span class="keyword">const</span> std::string&amp; msg) {</div>
<div class="line">            <span class="comment">// Network logic</span></div>
<div class="line">            <span class="comment">// Business logic</span></div>
<div class="line">            <span class="comment">// UI logic</span></div>
<div class="line">            <span class="comment">// Database logic</span></div>
<div class="line">            <span class="comment">// All mixed together!</span></div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md314"></a>
Testing</h1>
<h2><a class="anchor" id="autotoc_md315"></a>
✅ DO: Use Dependency Injection</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Testable design</span></div>
<div class="line"><span class="keyword">class </span>MessageProcessor {</div>
<div class="line">    std::shared_ptr&lt;IClient&gt; client_;  <span class="comment">// Interface</span></div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MessageProcessor(std::shared_ptr&lt;IClient&gt; client) </div>
<div class="line">        : client_(client) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> send_message(<span class="keyword">const</span> std::string&amp; msg) {</div>
<div class="line">        <span class="keywordflow">if</span> (client_-&gt;is_connected()) {</div>
<div class="line">            client_-&gt;send(msg);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In production</span></div>
<div class="line"><span class="keyword">auto</span> real_client = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">tcp_client</a>(<span class="stringliteral">&quot;server.com&quot;</span>, 8080).<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a5a4af5b627ffc15c727cba9fa2fa1d93">build</a>();</div>
<div class="line">MessageProcessor processor(real_client);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In tests</span></div>
<div class="line"><span class="keyword">auto</span> mock_client = std::make_shared&lt;MockClient&gt;();</div>
<div class="line">MessageProcessor processor(mock_client);</div>
<div class="line">EXPECT_CALL(*mock_client, send(<span class="stringliteral">&quot;test&quot;</span>));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md316"></a>
✅ DO: Test Error Scenarios</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Test error handling</span></div>
<div class="line">TEST(ClientTest, HandlesConnectionError) {</div>
<div class="line">    <span class="keywordtype">bool</span> error_received = <span class="keyword">false</span>;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">auto</span> client = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">tcp_client</a>(<span class="stringliteral">&quot;invalid.server&quot;</span>, 9999)</div>
<div class="line">        .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a13494649fcb5f8f8f4fbf8909a1e2e71">on_error</a>([&amp;](<span class="keyword">const</span> std::string&amp; error) {</div>
<div class="line">            error_received = <span class="keyword">true</span>;</div>
<div class="line">        })</div>
<div class="line">        .build();</div>
<div class="line">    </div>
<div class="line">    client-&gt;start();</div>
<div class="line">    std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">    </div>
<div class="line">    EXPECT_TRUE(error_received);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md317"></a>
✅ DO: Use Independent Context for Tests</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Isolated tests</span></div>
<div class="line">TEST(ClientTest, SendReceive) {</div>
<div class="line">    <span class="keyword">auto</span> client = <a class="code" href="namespaceunilink.html#a6e965071daa5a68d914844bfbf79daac">tcp_client</a>(<span class="stringliteral">&quot;127.0.0.1&quot;</span>, test_port)</div>
<div class="line">        .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a567fa16a7c094edee54a0ea2fec74fcd">use_independent_context</a>(<span class="keyword">true</span>)  <span class="comment">// Isolated I/O thread</span></div>
<div class="line">        .<a class="code" href="classunilink_1_1builder_1_1TcpClientBuilder.html#a5a4af5b627ffc15c727cba9fa2fa1d93">build</a>();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Test won&#39;t interfere with other tests</span></div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md319"></a>
Security</h1>
<h2><a class="anchor" id="autotoc_md320"></a>
✅ DO: Validate All Input</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Input validation</span></div>
<div class="line"><span class="keywordtype">void</span> handle_message(<span class="keyword">const</span> std::string&amp; msg) {</div>
<div class="line">    <span class="keywordflow">if</span> (msg.empty()) {</div>
<div class="line">        log_warning(<span class="stringliteral">&quot;Empty message received&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (msg.size() &gt; MAX_MESSAGE_SIZE) {</div>
<div class="line">        log_warning(<span class="stringliteral">&quot;Message too large&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (!is_valid_format(msg)) {</div>
<div class="line">        log_warning(<span class="stringliteral">&quot;Invalid message format&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    process_message(msg);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// BAD - No validation</span></div>
<div class="line"><span class="keywordtype">void</span> handle_message(<span class="keyword">const</span> std::string&amp; msg) {</div>
<div class="line">    process_message(msg);  <span class="comment">// Trusting input blindly</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md321"></a>
✅ DO: Implement Rate Limiting</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Rate limiting</span></div>
<div class="line"><span class="keyword">class </span>RateLimiter {</div>
<div class="line">    std::map&lt;size_t, std::deque&lt;TimePoint&gt;&gt; request_times_;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> max_requests_per_second_{10};</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> is_allowed(<span class="keywordtype">size_t</span> client_id) {</div>
<div class="line">        <span class="keyword">auto</span> now = std::chrono::steady_clock::now();</div>
<div class="line">        <span class="keyword">auto</span>&amp; times = request_times_[client_id];</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Remove old entries</span></div>
<div class="line">        <span class="keywordflow">while</span> (!times.empty() &amp;&amp; </div>
<div class="line">               now - times.front() &gt; std::chrono::seconds(1)) {</div>
<div class="line">            times.pop_front();</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (times.size() &gt;= max_requests_per_second_) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;  <span class="comment">// Rate limit exceeded</span></div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        times.push_back(now);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use in server</span></div>
<div class="line">server_-&gt;on_data([<span class="keyword">this</span>, limiter](<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> std::string&amp; data) {</div>
<div class="line">    <span class="keywordflow">if</span> (!limiter-&gt;is_allowed(<span class="keywordtype">id</span>)) {</div>
<div class="line">        log_warning(<span class="stringliteral">&quot;Rate limit exceeded for client &quot;</span> + std::to_string(id));</div>
<div class="line">        return;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    process_data(<span class="keywordtype">id</span>, data);</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md322"></a>
✅ DO: Set Connection Limits</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Limit connections</span></div>
<div class="line"><span class="keyword">class </span>Server {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> max_clients_{100};</div>
<div class="line">    std::atomic&lt;size_t&gt; current_clients_{0};</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> on_connect(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> std::string&amp; ip) {</div>
<div class="line">        <span class="keywordflow">if</span> (current_clients_ &gt;= max_clients_) {</div>
<div class="line">            log_warning(<span class="stringliteral">&quot;Max clients reached, rejecting &quot;</span> + ip);</div>
<div class="line">            server_-&gt;send_to_client(<span class="keywordtype">id</span>, <span class="stringliteral">&quot;Server full\n&quot;</span>);</div>
<div class="line">            <span class="comment">// Disconnect client</span></div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        current_clients_++;</div>
<div class="line">        <span class="comment">// Accept connection</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md324"></a>
Logging and Debugging</h1>
<h2><a class="anchor" id="autotoc_md325"></a>
✅ DO: Use Appropriate Log Levels</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Proper log levels</span></div>
<div class="line">logger.debug(<span class="stringliteral">&quot;client&quot;</span>, <span class="stringliteral">&quot;send&quot;</span>, <span class="stringliteral">&quot;Sending data: &quot;</span> + data);  <span class="comment">// Detailed</span></div>
<div class="line">logger.info(<span class="stringliteral">&quot;client&quot;</span>, <span class="stringliteral">&quot;connect&quot;</span>, <span class="stringliteral">&quot;Connected to server&quot;</span>);  <span class="comment">// Important events</span></div>
<div class="line">logger.warning(<span class="stringliteral">&quot;client&quot;</span>, <span class="stringliteral">&quot;retry&quot;</span>, <span class="stringliteral">&quot;Retrying connection&quot;</span>);  <span class="comment">// Potential issues</span></div>
<div class="line">logger.error(<span class="stringliteral">&quot;client&quot;</span>, <span class="stringliteral">&quot;send&quot;</span>, <span class="stringliteral">&quot;Send failed: &quot;</span> + error);  <span class="comment">// Errors</span></div>
<div class="line">logger.critical(<span class="stringliteral">&quot;system&quot;</span>, <span class="stringliteral">&quot;init&quot;</span>, <span class="stringliteral">&quot;Fatal initialization error&quot;</span>);  <span class="comment">// Critical</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// BAD - Wrong log levels</span></div>
<div class="line">logger.info(<span class="stringliteral">&quot;client&quot;</span>, <span class="stringliteral">&quot;send&quot;</span>, <span class="stringliteral">&quot;Sending data: &quot;</span> + data);  <span class="comment">// Too noisy</span></div>
<div class="line">logger.error(<span class="stringliteral">&quot;client&quot;</span>, <span class="stringliteral">&quot;connect&quot;</span>, <span class="stringliteral">&quot;Connected to server&quot;</span>);  <span class="comment">// Not an error!</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md326"></a>
✅ DO: Enable Debug Logging During Development</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Debug mode for development</span></div>
<div class="line"><span class="preprocessor">#ifdef DEBUG</span></div>
<div class="line">    unilink::common::Logger::instance().set_level(LogLevel::DEBUG);</div>
<div class="line">    unilink::common::ErrorHandler::instance().set_min_error_level(ErrorLevel::INFO);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    unilink::common::Logger::instance().set_level(LogLevel::WARNING);</div>
<div class="line">    unilink::common::ErrorHandler::instance().set_min_error_level(ErrorLevel::WARNING);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md327"></a>
✅ DO: Log Context Information</h2>
<div class="fragment"><div class="line"><span class="comment">// GOOD - Rich context</span></div>
<div class="line">logger.info(<span class="stringliteral">&quot;tcp_client&quot;</span>, <span class="stringliteral">&quot;connect&quot;</span>, </div>
<div class="line">    <span class="stringliteral">&quot;Connected to &quot;</span> + host + <span class="stringliteral">&quot;:&quot;</span> + std::to_string(port) + </div>
<div class="line">    <span class="stringliteral">&quot; (attempt &quot;</span> + std::to_string(attempt) + <span class="stringliteral">&quot;)&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// BAD - Insufficient context</span></div>
<div class="line">logger.info(<span class="stringliteral">&quot;tcp_client&quot;</span>, <span class="stringliteral">&quot;connect&quot;</span>, <span class="stringliteral">&quot;Connected&quot;</span>);  <span class="comment">// To what? When? How many attempts?</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Feb 7 2026 10:31:12 for unilink by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
