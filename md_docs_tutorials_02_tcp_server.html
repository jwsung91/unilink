<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>unilink: Tutorial 2: Building a TCP Server</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">unilink
   &#160;<span id="projectnumber">0.4.0</span>
   </div>
   <div id="projectbrief">A simple C++ library for unified async communication</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_docs_tutorials_02_tcp_server.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Tutorial 2: Building a TCP Server </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Learn how to create a robust TCP server with unilink.</p>
<p><b>Duration</b>: 20 minutes <br  />
 <b>Difficulty</b>: Beginner to Intermediate <br  />
 <b>Prerequisites</b>: <a class="el" href="md_docs_tutorials_01_getting_started.html">Tutorial 1: Getting Started</a></p>
<hr  />
<h1><a class="anchor" id="autotoc_md906"></a>
What You'll Build</h1>
<p>A TCP echo server that:</p><ol type="1">
<li>Accepts multiple client connections</li>
<li>Echoes back any received data</li>
<li>Tracks connected clients</li>
<li>Handles client disconnections gracefully</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md908"></a>
Step 1: Basic Server Setup</h1>
<p>Create <code>echo_server.cpp</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="unilink_8hpp.html">unilink/unilink.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EchoServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;unilink::wrapper::TcpServer&gt; server_;</div>
<div class="line">    std::atomic&lt;int&gt; client_count_{0};</div>
<div class="line">    uint16_t port_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    EchoServer(uint16_t port) : port_(port) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Starting echo server on port &quot;</span> &lt;&lt; port_ &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        server_ = <a class="code" href="namespaceunilink.html#a14c0a21a3c09f578b71455e31cf47956">unilink::tcp_server</a>(port_)</div>
<div class="line">            .<a class="code" href="classunilink_1_1builder_1_1TcpServerBuilder.html#add017de8e374447379b357729bf4cfdf">on_connect</a>([<span class="keyword">this</span>](<span class="keywordtype">size_t</span> client_id, <span class="keyword">const</span> std::string&amp; ip) {</div>
<div class="line">                handle_connect(client_id, ip);</div>
<div class="line">            })</div>
<div class="line">            .on_bytes([<span class="keyword">this</span>](<span class="keywordtype">size_t</span> client_id, <a class="code" href="classunilink_1_1memory_1_1SafeSpan.html">unilink::memory::ConstByteSpan</a> data) {</div>
<div class="line">                std::string str = <a class="code" href="namespaceunilink_1_1base_1_1safe__convert.html#a3c41d9c6266428458c97891710ac2f0d">unilink::common::safe_convert::uint8_to_string</a>(data.<a class="code" href="classunilink_1_1memory_1_1SafeSpan.html#a203851d86025e579f73f04da0828e2bd">data</a>(), data.<a class="code" href="classunilink_1_1memory_1_1SafeSpan.html#a0e63f52083142fa895b98ea38f51dc73">size</a>());</div>
<div class="line">                handle_data(client_id, str);</div>
<div class="line">            })</div>
<div class="line">            .on_disconnect([<span class="keyword">this</span>](<span class="keywordtype">size_t</span> client_id) {</div>
<div class="line">                handle_disconnect(client_id);</div>
<div class="line">            })</div>
<div class="line">            .on_error([<span class="keyword">this</span>](<span class="keyword">const</span> std::string&amp; error) {</div>
<div class="line">                handle_error(error);</div>
<div class="line">            })</div>
<div class="line">            .build();</div>
<div class="line">        </div>
<div class="line">        server_-&gt;start();</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Server started! Waiting for connections...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> handle_connect(<span class="keywordtype">size_t</span> client_id, <span class="keyword">const</span> std::string&amp; ip) {</div>
<div class="line">        client_count_++;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;[Client &quot;</span> &lt;&lt; client_id &lt;&lt; <span class="stringliteral">&quot;] Connected from &quot;</span> &lt;&lt; ip </div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot; (Total clients: &quot;</span> &lt;&lt; client_count_ &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Send welcome message</span></div>
<div class="line">        server_-&gt;send_to_client(client_id, <span class="stringliteral">&quot;Welcome to Echo Server!\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> handle_data(<span class="keywordtype">size_t</span> client_id, <span class="keyword">const</span> std::string&amp; data) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;[Client &quot;</span> &lt;&lt; client_id &lt;&lt; <span class="stringliteral">&quot;] Received: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Echo back the data</span></div>
<div class="line">        server_-&gt;send_to_client(client_id, <span class="stringliteral">&quot;Echo: &quot;</span> + data);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> handle_disconnect(<span class="keywordtype">size_t</span> client_id) {</div>
<div class="line">        client_count_--;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;[Client &quot;</span> &lt;&lt; client_id &lt;&lt; <span class="stringliteral">&quot;] Disconnected &quot;</span></div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;(Remaining clients: &quot;</span> &lt;&lt; client_count_ &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> handle_error(<span class="keyword">const</span> std::string&amp; error) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;[Error] &quot;</span> &lt;&lt; error &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        <span class="keywordflow">if</span> (server_) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Stopping server...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            server_-&gt;send(<span class="stringliteral">&quot;Server shutting down. Goodbye!\n&quot;</span>);</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">            server_-&gt;stop();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> is_running()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> server_ &amp;&amp; server_-&gt;is_listening();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    uint16_t port = (argc &gt; 1) ? std::stoi(argv[1]) : 8080;</div>
<div class="line">    </div>
<div class="line">    EchoServer server(port);</div>
<div class="line">    server.start();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Run until user presses Ctrl+C</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Press Ctrl+C to stop the server&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">while</span> (server.is_running()) {</div>
<div class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    server.stop();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassunilink_1_1builder_1_1TcpServerBuilder_html_add017de8e374447379b357729bf4cfdf"><div class="ttname"><a href="classunilink_1_1builder_1_1TcpServerBuilder.html#add017de8e374447379b357729bf4cfdf">unilink::builder::TcpServerBuilder::on_connect</a></div><div class="ttdeci">TcpServerBuilder &amp; on_connect(std::function&lt; void()&gt; handler) override</div><div class="ttdoc">Set connection handler callback (simple version)</div><div class="ttdef"><b>Definition:</b> <a href="tcp__server__builder_8cc_source.html#l00165">tcp_server_builder.cc:165</a></div></div>
<div class="ttc" id="aclassunilink_1_1memory_1_1SafeSpan_html"><div class="ttname"><a href="classunilink_1_1memory_1_1SafeSpan.html">unilink::memory::SafeSpan</a></div><div class="ttdoc">A C++17 compatible span-like class for safe array access.</div><div class="ttdef"><b>Definition:</b> <a href="safe__span_8hpp_source.html#l00038">safe_span.hpp:38</a></div></div>
<div class="ttc" id="aclassunilink_1_1memory_1_1SafeSpan_html_a0e63f52083142fa895b98ea38f51dc73"><div class="ttname"><a href="classunilink_1_1memory_1_1SafeSpan.html#a0e63f52083142fa895b98ea38f51dc73">unilink::memory::SafeSpan::size</a></div><div class="ttdeci">constexpr size_type size() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="safe__span_8hpp_source.html#l00081">safe_span.hpp:81</a></div></div>
<div class="ttc" id="aclassunilink_1_1memory_1_1SafeSpan_html_a203851d86025e579f73f04da0828e2bd"><div class="ttname"><a href="classunilink_1_1memory_1_1SafeSpan.html#a203851d86025e579f73f04da0828e2bd">unilink::memory::SafeSpan::data</a></div><div class="ttdeci">constexpr pointer data() const noexcept</div><div class="ttdef"><b>Definition:</b> <a href="safe__span_8hpp_source.html#l00079">safe_span.hpp:79</a></div></div>
<div class="ttc" id="anamespaceunilink_1_1base_1_1safe__convert_html_a3c41d9c6266428458c97891710ac2f0d"><div class="ttname"><a href="namespaceunilink_1_1base_1_1safe__convert.html#a3c41d9c6266428458c97891710ac2f0d">unilink::base::safe_convert::uint8_to_string</a></div><div class="ttdeci">std::string uint8_to_string(const uint8_t *data, size_t size)</div><div class="ttdoc">Safely convert uint8_t* to const char* for string operations.</div><div class="ttdef"><b>Definition:</b> <a href="common_8hpp_source.html#l00146">common.hpp:146</a></div></div>
<div class="ttc" id="anamespaceunilink_html_a14c0a21a3c09f578b71455e31cf47956"><div class="ttname"><a href="namespaceunilink.html#a14c0a21a3c09f578b71455e31cf47956">unilink::tcp_server</a></div><div class="ttdeci">builder::TcpServerBuilder tcp_server(uint16_t port)</div><div class="ttdoc">Create a TCP server builder.</div><div class="ttdef"><b>Definition:</b> <a href="unilink_8hpp_source.html#l00087">unilink.hpp:87</a></div></div>
<div class="ttc" id="aunilink_8hpp_html"><div class="ttname"><a href="unilink_8hpp.html">unilink.hpp</a></div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md910"></a>
Step 2: Build and Test</h1>
<h2><a class="anchor" id="autotoc_md911"></a>
Compile</h2>
<div class="fragment"><div class="line">g++ -std=c++17 echo_server.cpp -o echo_server -lunilink -lboost_system -pthread</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md912"></a>
Run Server</h2>
<div class="fragment"><div class="line">./echo_server 8080</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md913"></a>
Test with Multiple Clients</h2>
<p><b>Terminal 1</b> (Server): </p><div class="fragment"><div class="line">./echo_server 8080</div>
</div><!-- fragment --><p><b>Terminal 2</b> (Client 1): </p><div class="fragment"><div class="line">telnet localhost 8080</div>
</div><!-- fragment --><p><b>Terminal 3</b> (Client 2): </p><div class="fragment"><div class="line">telnet localhost 8080</div>
</div><!-- fragment --><p>Type messages in each client terminal and see them echoed back!</p>
<hr  />
<h1><a class="anchor" id="autotoc_md915"></a>
Step 3: Add Client Management</h1>
<p>Enhanced version with client tracking:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>AdvancedEchoServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>ClientInfo {</div>
<div class="line">        std::string ip;</div>
<div class="line">        std::chrono::system_clock::time_point connected_at;</div>
<div class="line">        <span class="keywordtype">size_t</span> messages_sent{0};</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::shared_ptr&lt;unilink::wrapper::TcpServer&gt; server_;</div>
<div class="line">    std::map&lt;size_t, ClientInfo&gt; clients_;</div>
<div class="line">    std::mutex clients_mutex_;</div>
<div class="line">    uint16_t port_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    AdvancedEchoServer(uint16_t port) : port_(port) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        server_ = <a class="code" href="namespaceunilink.html#a14c0a21a3c09f578b71455e31cf47956">unilink::tcp_server</a>(port_)</div>
<div class="line">            .<a class="code" href="classunilink_1_1builder_1_1TcpServerBuilder.html#add017de8e374447379b357729bf4cfdf">on_connect</a>([<span class="keyword">this</span>](<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> std::string&amp; ip) {</div>
<div class="line">                std::lock_guard&lt;std::mutex&gt; lock(clients_mutex_);</div>
<div class="line">                clients_[id] = {ip, std::chrono::system_clock::now(), 0};</div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;[Client &quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;] Connected from &quot;</span> &lt;&lt; ip &lt;&lt; std::endl;</div>
<div class="line">                server_-&gt;send_to_client(<span class="keywordtype">id</span>, <span class="stringliteral">&quot;Welcome! You are client #&quot;</span> + </div>
<div class="line">                                       std::to_string(<span class="keywordtype">id</span>) + <span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line">            })</div>
<div class="line">            .on_bytes([<span class="keyword">this</span>](<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, <a class="code" href="classunilink_1_1memory_1_1SafeSpan.html">unilink::memory::ConstByteSpan</a> data) {</div>
<div class="line">                {</div>
<div class="line">                    std::lock_guard&lt;std::mutex&gt; lock(clients_mutex_);</div>
<div class="line">                    <span class="keywordflow">if</span> (clients_.count(<span class="keywordtype">id</span>)) {</div>
<div class="line">                        clients_[id].messages_sent++;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                std::string str = <a class="code" href="namespaceunilink_1_1base_1_1safe__convert.html#a3c41d9c6266428458c97891710ac2f0d">unilink::common::safe_convert::uint8_to_string</a>(data.<a class="code" href="classunilink_1_1memory_1_1SafeSpan.html#a203851d86025e579f73f04da0828e2bd">data</a>(), data.<a class="code" href="classunilink_1_1memory_1_1SafeSpan.html#a0e63f52083142fa895b98ea38f51dc73">size</a>());</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Handle commands</span></div>
<div class="line">                <span class="keywordflow">if</span> (str == <span class="stringliteral">&quot;/stats\n&quot;</span>) {</div>
<div class="line">                    send_statistics(<span class="keywordtype">id</span>);</div>
<div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str == <span class="stringliteral">&quot;/clients\n&quot;</span>) {</div>
<div class="line">                    send_client_list(<span class="keywordtype">id</span>);</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    <span class="comment">// Echo normally</span></div>
<div class="line">                    server_-&gt;send_to_client(<span class="keywordtype">id</span>, <span class="stringliteral">&quot;Echo: &quot;</span> + str);</div>
<div class="line">                }</div>
<div class="line">            })</div>
<div class="line">            .on_disconnect([<span class="keyword">this</span>](<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>) {</div>
<div class="line">                std::lock_guard&lt;std::mutex&gt; lock(clients_mutex_);</div>
<div class="line">                clients_.erase(<span class="keywordtype">id</span>);</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;[Client &quot;</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">&quot;] Disconnected&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            })</div>
<div class="line">            .build();</div>
<div class="line">        </div>
<div class="line">        server_-&gt;start();</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Advanced Echo Server started on port &quot;</span> &lt;&lt; port_ &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> send_statistics(<span class="keywordtype">size_t</span> client_id) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(clients_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (clients_.count(client_id) == 0) <span class="keywordflow">return</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span>&amp; info = clients_[client_id];</div>
<div class="line">        <span class="keyword">auto</span> duration = std::chrono::system_clock::now() - info.connected_at;</div>
<div class="line">        <span class="keyword">auto</span> seconds = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(duration).count();</div>
<div class="line">        </div>
<div class="line">        std::string stats = <span class="stringliteral">&quot;=== Your Statistics ===\n&quot;</span>;</div>
<div class="line">        stats += <span class="stringliteral">&quot;IP: &quot;</span> + info.ip + <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        stats += <span class="stringliteral">&quot;Connected for: &quot;</span> + std::to_string(seconds) + <span class="stringliteral">&quot; seconds\n&quot;</span>;</div>
<div class="line">        stats += <span class="stringliteral">&quot;Messages sent: &quot;</span> + std::to_string(info.messages_sent) + <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        stats += <span class="stringliteral">&quot;======================\n&quot;</span>;</div>
<div class="line">        </div>
<div class="line">        server_-&gt;send_to_client(client_id, stats);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> send_client_list(<span class="keywordtype">size_t</span> client_id) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(clients_mutex_);</div>
<div class="line">        </div>
<div class="line">        std::string list = <span class="stringliteral">&quot;=== Connected Clients ===\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [<span class="keywordtype">id</span>, info] : clients_) {</div>
<div class="line">            list += <span class="stringliteral">&quot;Client &quot;</span> + std::to_string(<span class="keywordtype">id</span>) + <span class="stringliteral">&quot;: &quot;</span> + info.ip;</div>
<div class="line">            <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == client_id) list += <span class="stringliteral">&quot; (you)&quot;</span>;</div>
<div class="line">            list += <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        list += <span class="stringliteral">&quot;Total: &quot;</span> + std::to_string(clients_.size()) + <span class="stringliteral">&quot; clients\n&quot;</span>;</div>
<div class="line">        list += <span class="stringliteral">&quot;========================\n&quot;</span>;</div>
<div class="line">        </div>
<div class="line">        server_-&gt;send_to_client(client_id, list);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        <span class="keywordflow">if</span> (server_) {</div>
<div class="line">            server_-&gt;send(<span class="stringliteral">&quot;Server shutting down...\n&quot;</span>);</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">            server_-&gt;stop();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md917"></a>
Step 4: Single Client Mode</h1>
<p>For applications that only need one client at a time:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> server = <a class="code" href="namespaceunilink.html#a14c0a21a3c09f578b71455e31cf47956">unilink::tcp_server</a>(8080)</div>
<div class="line">    .<a class="code" href="classunilink_1_1builder_1_1TcpServerBuilder.html#a9349e7963408c74d2dac92fae288cddc">single_client</a>()  <span class="comment">// Only accept one client</span></div>
<div class="line">    .<a class="code" href="classunilink_1_1builder_1_1TcpServerBuilder.html#add017de8e374447379b357729bf4cfdf">on_connect</a>([](<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> std::string&amp; ip) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Client connected: &quot;</span> &lt;&lt; ip &lt;&lt; std::endl;</div>
<div class="line">        <span class="comment">// Previous client is automatically disconnected</span></div>
<div class="line">    })</div>
<div class="line">    .on_bytes([](<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, <a class="code" href="classunilink_1_1memory_1_1SafeSpan.html">unilink::memory::ConstByteSpan</a> data) {</div>
<div class="line">        std::string str = <a class="code" href="namespaceunilink_1_1base_1_1safe__convert.html#a3c41d9c6266428458c97891710ac2f0d">unilink::common::safe_convert::uint8_to_string</a>(data.<a class="code" href="classunilink_1_1memory_1_1SafeSpan.html#a203851d86025e579f73f04da0828e2bd">data</a>(), data.<a class="code" href="classunilink_1_1memory_1_1SafeSpan.html#a0e63f52083142fa895b98ea38f51dc73">size</a>());</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Received: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</div>
<div class="line">    })</div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line">server-&gt;start();</div>
<div class="line"><span class="comment">// ... do work ...</span></div>
<div class="line">server-&gt;stop();  <span class="comment">// Clean shutdown when done</span></div>
<div class="ttc" id="aclassunilink_1_1builder_1_1TcpServerBuilder_html_a9349e7963408c74d2dac92fae288cddc"><div class="ttname"><a href="classunilink_1_1builder_1_1TcpServerBuilder.html#a9349e7963408c74d2dac92fae288cddc">unilink::builder::TcpServerBuilder::single_client</a></div><div class="ttdeci">TcpServerBuilder &amp; single_client()</div><div class="ttdoc">Configure server for single client mode.</div><div class="ttdef"><b>Definition:</b> <a href="tcp__server__builder_8cc_source.html#l00230">tcp_server_builder.cc:230</a></div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md919"></a>
Step 5: Port Retry Logic</h1>
<p>Handle cases where the port might be in use:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> server = <a class="code" href="namespaceunilink.html#a14c0a21a3c09f578b71455e31cf47956">unilink::tcp_server</a>(8080)</div>
<div class="line">    .<a class="code" href="classunilink_1_1builder_1_1TcpServerBuilder.html#a5361cef3aa804d32cba0b73c02e6492d">enable_port_retry</a>(</div>
<div class="line">        <span class="keyword">true</span>,   <span class="comment">// Enable retry</span></div>
<div class="line">        5,      <span class="comment">// Try 5 times</span></div>
<div class="line">        1000    <span class="comment">// Wait 1 second between attempts</span></div>
<div class="line">    )</div>
<div class="line">    .<a class="code" href="classunilink_1_1builder_1_1TcpServerBuilder.html#a56c7eb778bed9c2b217704a081d59fea">on_error</a>([](<span class="keyword">const</span> std::string&amp; error) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Server error: &quot;</span> &lt;&lt; error &lt;&lt; std::endl;</div>
<div class="line">    })</div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line">server-&gt;start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check if server started successfully</span></div>
<div class="line">std::this_thread::sleep_for(std::chrono::seconds(6)); <span class="comment">// Wait for retries</span></div>
<div class="line"><span class="keywordflow">if</span> (!server-&gt;is_listening()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to start server after retries&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... do work ...</span></div>
<div class="line">server-&gt;stop();  <span class="comment">// Clean shutdown</span></div>
<div class="ttc" id="aclassunilink_1_1builder_1_1TcpServerBuilder_html_a5361cef3aa804d32cba0b73c02e6492d"><div class="ttname"><a href="classunilink_1_1builder_1_1TcpServerBuilder.html#a5361cef3aa804d32cba0b73c02e6492d">unilink::builder::TcpServerBuilder::enable_port_retry</a></div><div class="ttdeci">TcpServerBuilder &amp; enable_port_retry(bool enable=true, int max_retries=3, int retry_interval_ms=1000)</div><div class="ttdoc">Enable port binding retry on failure.</div><div class="ttdef"><b>Definition:</b> <a href="tcp__server__builder_8cc_source.html#l00211">tcp_server_builder.cc:211</a></div></div>
<div class="ttc" id="aclassunilink_1_1builder_1_1TcpServerBuilder_html_a56c7eb778bed9c2b217704a081d59fea"><div class="ttname"><a href="classunilink_1_1builder_1_1TcpServerBuilder.html#a56c7eb778bed9c2b217704a081d59fea">unilink::builder::TcpServerBuilder::on_error</a></div><div class="ttdeci">TcpServerBuilder &amp; on_error(std::function&lt; void(const std::string &amp;)&gt; handler) override</div><div class="ttdoc">Set error handler callback.</div><div class="ttdef"><b>Definition:</b> <a href="tcp__server__builder_8cc_source.html#l00185">tcp_server_builder.cc:185</a></div></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md921"></a>
Step 6: Broadcasting to All Clients</h1>
<p>Send messages to all connected clients:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>BroadcastServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;unilink::wrapper::TcpServer&gt; server_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        server_ = <a class="code" href="namespaceunilink.html#a14c0a21a3c09f578b71455e31cf47956">unilink::tcp_server</a>(8080)</div>
<div class="line">            .on_bytes([<span class="keyword">this</span>](<span class="keywordtype">size_t</span> sender_id, <a class="code" href="classunilink_1_1memory_1_1SafeSpan.html">unilink::memory::ConstByteSpan</a> data) {</div>
<div class="line">                std::string str = <a class="code" href="namespaceunilink_1_1base_1_1safe__convert.html#a3c41d9c6266428458c97891710ac2f0d">unilink::common::safe_convert::uint8_to_string</a>(data.<a class="code" href="classunilink_1_1memory_1_1SafeSpan.html#a203851d86025e579f73f04da0828e2bd">data</a>(), data.<a class="code" href="classunilink_1_1memory_1_1SafeSpan.html#a0e63f52083142fa895b98ea38f51dc73">size</a>());</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Broadcast to all clients</span></div>
<div class="line">                std::string msg = <span class="stringliteral">&quot;[Client &quot;</span> + std::to_string(sender_id) + <span class="stringliteral">&quot;]: &quot;</span> + str;</div>
<div class="line">                server_-&gt;send(msg);  <span class="comment">// Send to ALL clients</span></div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Broadcasted: &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</div>
<div class="line">            })</div>
<div class="line">            .build();</div>
<div class="line">        </div>
<div class="line">        server_-&gt;start();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md923"></a>
Complete Example: Chat Server</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="unilink_8hpp.html">unilink/unilink.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ChatServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;unilink::wrapper::TcpServer&gt; server_;</div>
<div class="line">    std::map&lt;size_t, std::string&gt; nicknames_;</div>
<div class="line">    std::mutex mutex_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> start(uint16_t port) {</div>
<div class="line">        server_ = <a class="code" href="namespaceunilink.html#a14c0a21a3c09f578b71455e31cf47956">unilink::tcp_server</a>(port)</div>
<div class="line">            .<a class="code" href="classunilink_1_1builder_1_1TcpServerBuilder.html#add017de8e374447379b357729bf4cfdf">on_connect</a>([<span class="keyword">this</span>](<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> std::string&amp; ip) {</div>
<div class="line">                std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">                nicknames_[id] = <span class="stringliteral">&quot;User&quot;</span> + std::to_string(<span class="keywordtype">id</span>);</div>
<div class="line">                </div>
<div class="line">                std::string msg = nicknames_[id] + <span class="stringliteral">&quot; joined the chat!\n&quot;</span>;</div>
<div class="line">                server_-&gt;send(msg);</div>
<div class="line">                std::cout &lt;&lt; msg;</div>
<div class="line">                </div>
<div class="line">                server_-&gt;send_to_client(<span class="keywordtype">id</span>, <span class="stringliteral">&quot;Welcome! Type /nick &lt;name&gt; to set your nickname\n&quot;</span>);</div>
<div class="line">            })</div>
<div class="line">            .on_bytes([<span class="keyword">this</span>](<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, <a class="code" href="classunilink_1_1memory_1_1SafeSpan.html">unilink::memory::ConstByteSpan</a> data) {</div>
<div class="line">                std::string str = <a class="code" href="namespaceunilink_1_1base_1_1safe__convert.html#a3c41d9c6266428458c97891710ac2f0d">unilink::common::safe_convert::uint8_to_string</a>(data.<a class="code" href="classunilink_1_1memory_1_1SafeSpan.html#a203851d86025e579f73f04da0828e2bd">data</a>(), data.<a class="code" href="classunilink_1_1memory_1_1SafeSpan.html#a0e63f52083142fa895b98ea38f51dc73">size</a>());</div>
<div class="line">                handle_message(<span class="keywordtype">id</span>, str);</div>
<div class="line">            })</div>
<div class="line">            .on_disconnect([<span class="keyword">this</span>](<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>) {</div>
<div class="line">                std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">                std::string msg = nicknames_[id] + <span class="stringliteral">&quot; left the chat.\n&quot;</span>;</div>
<div class="line">                nicknames_.erase(<span class="keywordtype">id</span>);</div>
<div class="line">                </div>
<div class="line">                server_-&gt;send(msg);</div>
<div class="line">                std::cout &lt;&lt; msg;</div>
<div class="line">            })</div>
<div class="line">            .build();</div>
<div class="line">        </div>
<div class="line">        server_-&gt;start();</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Chat server started on port &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> handle_message(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> std::string&amp; data) {</div>
<div class="line">        <span class="keywordflow">if</span> (data.substr(0, 5) == <span class="stringliteral">&quot;/nick&quot;</span>) {</div>
<div class="line">            <span class="comment">// Change nickname</span></div>
<div class="line">            std::string new_nick = data.substr(6);</div>
<div class="line">            new_nick.erase(new_nick.find_last_not_of(<span class="stringliteral">&quot; \n\r\t&quot;</span>) + 1);</div>
<div class="line">            </div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">            std::string old_nick = nicknames_[id];</div>
<div class="line">            nicknames_[id] = new_nick;</div>
<div class="line">            </div>
<div class="line">            std::string msg = old_nick + <span class="stringliteral">&quot; is now known as &quot;</span> + new_nick + <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            server_-&gt;send(msg);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// Broadcast message</span></div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">            std::string msg = nicknames_[id] + <span class="stringliteral">&quot;: &quot;</span> + data;</div>
<div class="line">            server_-&gt;send(msg);</div>
<div class="line">            std::cout &lt;&lt; msg;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    uint16_t port = (argc &gt; 1) ? std::stoi(argv[1]) : 8080;</div>
<div class="line">    </div>
<div class="line">    ChatServer server;</div>
<div class="line">    server.start(port);</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Chat server running. Press Ctrl+C to stop.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md925"></a>
Testing Your Chat Server</h1>
<h2><a class="anchor" id="autotoc_md926"></a>
Start Server</h2>
<div class="fragment"><div class="line">./chat_server 8080</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md927"></a>
Connect Multiple Clients</h2>
<div class="fragment"><div class="line"># Terminal 1</div>
<div class="line">telnet localhost 8080</div>
<div class="line"> </div>
<div class="line"># Terminal 2</div>
<div class="line">telnet localhost 8080</div>
<div class="line"> </div>
<div class="line"># Terminal 3</div>
<div class="line">telnet localhost 8080</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md928"></a>
Try Commands</h2>
<div class="fragment"><div class="line">/nick Alice</div>
<div class="line">Hello everyone!</div>
<div class="line">/nick Bob</div>
<div class="line">Hi Alice!</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md930"></a>
Best Practices</h1>
<h2><a class="anchor" id="autotoc_md931"></a>
1. Always Check Server Status</h2>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!server-&gt;is_listening()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Server failed to start&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md932"></a>
2. Use Thread-Safe Data Structures</h2>
<div class="fragment"><div class="line">std::mutex mutex_;</div>
<div class="line">std::map&lt;size_t, ClientInfo&gt; clients_;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Always lock when accessing shared data</span></div>
<div class="line">{</div>
<div class="line">    std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">    clients_[id] = info;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md933"></a>
3. Handle Graceful Shutdown</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> shutdown() {</div>
<div class="line">    <span class="comment">// Notify clients</span></div>
<div class="line">    server_-&gt;send(<span class="stringliteral">&quot;Server shutting down...\n&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait for messages to be sent</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Stop server</span></div>
<div class="line">    server_-&gt;stop();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md934"></a>
4. Implement Error Recovery</h2>
<div class="fragment"><div class="line">.on_error([<span class="keyword">this</span>](<span class="keyword">const</span> std::string&amp; error) {</div>
<div class="line">    log_error(error);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Attempt recovery if needed</span></div>
<div class="line">    <span class="keywordflow">if</span> (is_recoverable(error)) {</div>
<div class="line">        attempt_recovery();</div>
<div class="line">    }</div>
<div class="line">})</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md936"></a>
Common Patterns</h1>
<h2><a class="anchor" id="autotoc_md937"></a>
Pattern 1: Command Parser</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> handle_command(<span class="keywordtype">size_t</span> client_id, <span class="keyword">const</span> std::string&amp; cmd) {</div>
<div class="line">    <span class="keywordflow">if</span> (cmd == <span class="stringliteral">&quot;/help&quot;</span>) {</div>
<div class="line">        send_help(client_id);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmd == <span class="stringliteral">&quot;/quit&quot;</span>) {</div>
<div class="line">        disconnect_client(client_id);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cmd.substr(0, 5) == <span class="stringliteral">&quot;/msg &quot;</span>) {</div>
<div class="line">        send_private_message(client_id, cmd.substr(5));</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        server_-&gt;send_to_client(client_id, <span class="stringliteral">&quot;Unknown command\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md938"></a>
Pattern 2: Rate Limiting</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>RateLimiter {</div>
<div class="line">    <span class="keywordtype">size_t</span> max_messages_per_second{10};</div>
<div class="line">    std::map&lt;size_t, std::deque&lt;std::chrono::steady_clock::time_point&gt;&gt; timestamps;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> is_allowed(<span class="keywordtype">size_t</span> client_id) {</div>
<div class="line">        <span class="keyword">auto</span> now = std::chrono::steady_clock::now();</div>
<div class="line">        <span class="keyword">auto</span>&amp; times = timestamps[client_id];</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Remove old timestamps</span></div>
<div class="line">        <span class="keywordflow">while</span> (!times.empty() &amp;&amp; </div>
<div class="line">               now - times.front() &gt; std::chrono::seconds(1)) {</div>
<div class="line">            times.pop_front();</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Check limit</span></div>
<div class="line">        <span class="keywordflow">if</span> (times.size() &gt;= max_messages_per_second) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        times.push_back(now);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md940"></a>
Next Steps</h1>
<ul>
<li>Tutorial 3: Serial Communication →</li>
<li>../guides/best_practices.md "Best Practices Guide"</li>
<li>../guides/performance_tuning.md "Performance Tuning"</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md942"></a>
Full Example Code</h1>
<p>✅ <b>Ready-to-compile examples are available!</b></p>
<p><b>Location</b>: <code>examples/tutorials/tcp_server/</code></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">File   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>echo_server.cpp</code>   </td><td class="markdownTableBodyNone">Basic echo server from this tutorial    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>chat_server.cpp</code>   </td><td class="markdownTableBodyNone">Complete chat server with commands   </td></tr>
</table>
<p><b>Build and run</b>: </p><div class="fragment"><div class="line"># Build echo server</div>
<div class="line">cmake --build build --target tutorial_echo_server</div>
<div class="line">./build/examples/tutorials/tutorial_echo_server 8080</div>
<div class="line"> </div>
<div class="line"># Build chat server</div>
<div class="line">cmake --build build --target tutorial_chat_server</div>
<div class="line">./build/examples/tutorials/tutorial_chat_server 8080</div>
</div><!-- fragment --><p>See examples/tutorials/README.md for detailed build instructions.</p>
<hr  />
<p><b>Previous</b>: <a class="el" href="md_docs_tutorials_01_getting_started.html">← Getting Started</a> <br  />
 <b>Next</b>: Serial Communication → </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Feb 10 2026 02:06:54 for unilink by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
